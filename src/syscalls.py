import ctypes
import ctypes.wintypes as wintypes

# constants
IMAGE_DOS_SIGNATURE = 0x5A4D
IMAGE_NT_SIGNATURE = 0x00004550

class IMAGE_DOS_HEADER(ctypes.Structure):
    _fields_ = [
        ("e_magic", wintypes.WORD),
        ("e_cblp", wintypes.WORD),
        ("e_cp", wintypes.WORD),
        ("e_crlc", wintypes.WORD),
        ("e_cparhdr", wintypes.WORD),
        ("e_minalloc", wintypes.WORD),
        ("e_maxalloc", wintypes.WORD),
        ("e_ss", wintypes.WORD),
        ("e_sp", wintypes.WORD),
        ("e_csum", wintypes.WORD),
        ("e_ip", wintypes.WORD),
        ("e_cs", wintypes.WORD),
        ("e_lfarlc", wintypes.WORD),
        ("e_ovno", wintypes.WORD),
        ("e_res", wintypes.WORD * 4),
        ("e_oemid", wintypes.WORD),
        ("e_oeminfo", wintypes.WORD),
        ("e_res2", wintypes.WORD * 10),
        ("e_lfanew", wintypes.LONG)
    ]

class IMAGE_EXPORT_DIRECTORY(ctypes.Structure):
    _fields_ = [
        ("Characteristics", wintypes.DWORD),
        ("TimeDateStamp", wintypes.DWORD),
        ("MajorVersion", wintypes.WORD),
        ("MinorVersion", wintypes.WORD),
        ("Name", wintypes.DWORD),
        ("Base", wintypes.DWORD),
        ("NumberOfFunctions", wintypes.DWORD),
        ("NumberOfNames", wintypes.DWORD),
        ("AddressOfFunctions", wintypes.DWORD),
        ("AddressOfNames", wintypes.DWORD),
        ("AddressOfNameOrdinals", wintypes.DWORD)
    ]

# load ntdll
ntdll_handle = ctypes.windll.kernel32.GetModuleHandleW("ntdll.dll")
ntdll_base = ctypes.c_void_p(ntdll_handle)

# parse headers
dos_header = IMAGE_DOS_HEADER.from_address(ntdll_base.value)
nt_headers_addr = ntdll_base.value + dos_header.e_lfanew
export_dir_rva_offset = nt_headers_addr + 0x18 + 0x70  # optional header offset to export table
export_rva = ctypes.c_uint32.from_address(export_dir_rva_offset).value
export_dir = IMAGE_EXPORT_DIRECTORY.from_address(ntdll_base.value + export_rva)

# read arrays
AddressOfFunctions = (ctypes.c_uint32 * export_dir.NumberOfFunctions).from_address(ntdll_base.value + export_dir.AddressOfFunctions)
AddressOfNames = (ctypes.c_uint32 * export_dir.NumberOfNames).from_address(ntdll_base.value + export_dir.AddressOfNames)
AddressOfNameOrdinals = (ctypes.c_uint16 * export_dir.NumberOfNames).from_address(ntdll_base.value + export_dir.AddressOfNameOrdinals)

# create output file
with open("ntdll_syscalls.py", "w") as f:
    f.write("# autogenerated ntdll syscall stubs\n\n")
    f.write("import ctypes\n\n")
    f.write("syscalls = {}\n\n")

    for i in range(export_dir.NumberOfNames):
        name_rva = AddressOfNames[i]
        func_name = ctypes.c_char_p(ntdll_base.value + name_rva).value
        if not func_name or not func_name.startswith(b"Nt"):
            continue

        ordinal = AddressOfNameOrdinals[i]
        func_rva = AddressOfFunctions[ordinal]
        func_addr = ntdll_base.value + func_rva

        data = (ctypes.c_ubyte * 20).from_address(func_addr)
        syscall_number = None
        for j in range(len(data)-5):
            if data[j] == 0xB8:  # mov eax, imm32
                syscall_number = int.from_bytes(bytes(data[j+1:j+5]), "little")
                break
        if syscall_number is not None:
            func_name_str = func_name.decode()
            f.write(f"syscalls['{func_name_str}'] = {syscall_number}\n")

print("ntdll_syscalls.py generated successfully!")
